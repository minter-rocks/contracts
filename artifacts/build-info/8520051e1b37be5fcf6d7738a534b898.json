{
  "id": "8520051e1b37be5fcf6d7738a534b898",
  "_format": "hh-sol-build-info-1",
  "solcVersion": "0.8.13",
  "solcLongVersion": "0.8.13+commit.abaa5c0e",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/Collection3.sol": {
        "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.4;\n\n// /**                                   .----------------. \n//  *                                   | .--------------. |\n//  *                                   | |  _______     | |\n//  *                                   | | |_   __ \\    | |\n//  *                                   | |   | |__) |   | |\n//  *                                   | |   |  __ /    | |\n//  *                                   | |  _| |  \\ \\_  | |\n//  *                                   | | |____| |___| | |\n//  *                                   | |              | |\n//  *                                   | '--------------' |\n//  *                                   '------------------' \n//  *\n//  *   ███╗   ███╗██╗███╗   ██╗████████╗███████╗██████╗    ██████╗  ██████╗  ██████╗██╗  ██╗███████╗\n//  *   ████╗ ████║██║████╗  ██║╚══██╔══╝██╔════╝██╔══██╗   ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝██╔════╝\n//  *   ██╔████╔██║██║██╔██╗ ██║   ██║   █████╗  ██████╔╝   ██████╔╝██║   ██║██║     █████╔╝ ███████╗\n//  *   ██║╚██╔╝██║██║██║╚██╗██║   ██║   ██╔══╝  ██╔══██╗   ██╔══██╗██║   ██║██║     ██╔═██╗ ╚════██║\n//  *   ██║ ╚═╝ ██║██║██║ ╚████║   ██║   ███████╗██║  ██║██╗██║  ██║╚██████╔╝╚██████╗██║  ██╗███████║\n//  *   ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝\n//  */\n\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\n\n// /**\n//  * @title NFT Collection contract version_3\n//  * @notice the contract is ERC721 enumerable.\n//  * @notice tokenIds are starting from 0 to (maxSupply - 1).\n//  * @notice tokenURIs are all in the same format baseURI/tokenId.\n//  * @notice totalSupply is limited but can be set by the owner.\n//  * @notice safeMint by auto increment only.\n//  * @notice safeMint public and payable and _mintFee increases by the tokenId.\n//  * @notice there is a default royalty which can be set once at initializing time.\n//  * @notice the contract receives royalties.\n//  * @notice owner of the contract can delete default royalty.\n//  * @notice every one can log a comment in the contract but the comment fee varies for token owners.\n//  */\n// contract Collection is Initializable, ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721BurnableUpgradeable, ERC721RoyaltyUpgradeable, OwnableUpgradeable, UUPSUpgradeable {\n//     using CountersUpgradeable for CountersUpgradeable.Counter;\n\n//     CountersUpgradeable.Counter private _tokenIdCounter;\n\n//     /**\n//      * @notice creator of the Collection.\n//      */\n//     string public _creator_;\n\n//     event SetCreatorName(string _creatorName);\n//     /**\n//      * @notice change the creator name.\n//      * @param _creatorName new name of the creator.\n//      * @notice only owner of the contract can call this function.\n//      */\n//     function setCreatorName(string memory _creatorName) public onlyOwner {\n//         _creator_ = _creatorName;\n//         emit SetCreatorName(_creatorName);\n//     }\n\n//     /**\n//      * @notice the base URI of the collection on IPFS.\n//      */\n//     string private _baseURI_;\n\n//     event SetBaseURI(string baseURI_);\n//     /**\n//      * @notice change the baseURI.\n//      * @param baseURI_ base URI of the tokens.\n//      * @notice only owner of the contract can call this function.\n//      */\n//     function setBaseURI(string memory baseURI_) public onlyOwner {\n//         _baseURI_ = baseURI_;\n//         emit SetBaseURI(baseURI_);\n//     }\n\n//     /**\n//      * @notice override -baseURI function to define functionality.\n//      */\n//     function _baseURI() internal view override returns (string memory) {\n//         return _baseURI_;\n//     }\n\n//     /**\n//      * @notice maximum number of tokens can be minted.\n//      */\n//     uint256 public maxSupply;\n\n//     event SetMaxSupply(uint256 _maxSupply);\n//     /**\n//      * @notice change the maximum Supply.\n//      * @param _maxSupply new maximum Supply.\n//      * @notice only owner of the contract can call this function.\n//      * @notice the new maximum Supply must be greater than or equal to the current supply.\n//      */\n//     function setMaxSupply(uint256 _maxSupply) public onlyOwner {\n//         require(_maxSupply >= _tokenIdCounter.current(), \"Collection: maxSupply must be greater than or equal to the current supply.\");\n//         maxSupply = _maxSupply;\n//         emit SetMaxSupply(_maxSupply);\n//     }\n\n\n//     /// @custom:oz-upgrades-unsafe-allow constructor\n//     constructor() {\n//         _disableInitializers();\n//     }\n\n//     /**\n//      * @notice initialize the Collection called by the Factory.\n//      * @dev can be called only one time.\n//      */\n//     function initialize() initializer public {\n//         _creator_ = \"Renope\"; //creator of the Collection.\n//         __ERC721_init(\"collection3\", \"c3\");\n//         __ERC721Enumerable_init();\n//         __ERC721Burnable_init();\n//         __Ownable_init(msg.sender);\n//         _baseURI_ = \"\"; //the base uRI of the collection on IPFS.\n//         maxSupply = 100; //maximum number of tokens can be minted.\n//         _setDefaultRoyalty(address(this), 500);\n//         baseMintFee = 0.05 * 10 ** 18; //the base fee required to mint the first token.\n//         mintFeeRatioNumerator = 200; //the numerator of mint fee ratio which denumerator is 10000.\n//         tokenHoldersCommentFee = 0.005 * 10 ** 18; //comment fee for the token holders.\n//         guestsCommentFee = 0.01 * 10 ** 18; //comment fee for regular people.\n//     }\n\n//     mapping(address => string) users;\n//     mapping(string => address) registered;\n\n//     event Register(address _userAddr, string username);\n//     /**\n//      * @notice set a username on your wallet address.\n//      * @param _username the new username you set.\n//      * @notice you cannot use preselected usernames.\n//      */\n//     function register(string memory _username) public {\n//         require(registered[_username] == address(0), \"Collection: the username has already been registered\");\n//         users[msg.sender] = _username;\n//         emit Register(msg.sender, _username);\n//     }\n\n//     event UnRegister(address _userAddr);\n//     /**\n//      * @notice delete your username.\n//      */\n//     function unRegister() public {\n//         delete registered[users[msg.sender]];\n//         delete users[msg.sender];\n//         emit UnRegister(msg.sender);\n//     }\n\n//     /**\n//      * @notice returns the username of the specified address.\n//      */\n//     function username(address userAddr) public view returns(string memory) {\n//         return users[userAddr];\n//     }\n\n//     /**\n//      * @notice returns the username of the specified tokenId's owner.\n//      */\n//     function ownerName(uint256 tokenId) public view returns(string memory) {\n//         return username(ownerOf(tokenId));\n//     }\n\n//     /**\n//      * @notice returns token balance of the specified _username.\n//      */\n//     function userBalance(string memory _username) public view returns(uint256) {\n//         return balanceOf(registered[_username]);\n//     }\n\n\n//     uint256 baseMintFee;\n//     function setBaseMintFee(uint256 _baseMintFee) public onlyOwner {\n//         baseMintFee = _baseMintFee;\n//     }\n    \n//     uint256 mintFeeRatioNumerator;\n//     function setMintFeeRatioNumerator(uint256 _mintFeeRatioNumerator) public onlyOwner {\n//         mintFeeRatioNumerator = _mintFeeRatioNumerator;\n//     }\n\n//     /**\n//      * @notice returns required fee to mint the next token(s).\n//      */\n//     function mintFee(uint256 tokenWeight) public view returns(uint256) {\n//         uint256 tokenId =  _tokenIdCounter.current();\n//         return tokenWeight * (baseMintFee + (baseMintFee * tokenId * mintFeeRatioNumerator / 10000 ));\n//     }\n\n//     /**\n//      * @notice mint a new token.\n//      * @param to address that will own the token.\n//      * @dev the tokenId will be earned automatically.\n//      * @notice only owner of the contract can call this function.\n//      */\n//     function safeMint(address to, uint256 tokenWeight) public payable {\n//         uint256 tokenId = _tokenIdCounter.current();\n//         require(msg.value >= _mintFee(tokenId), \"Collection: insufficient mint fee\");\n//         _tokenIdCounter.increment();\n//         _setTokenWeight(tokenWeight);\n//         _safeMint(to, tokenId);\n//     }\n\n//     /**\n//      * @notice override mint function to change functionality.\n//      * @notice tokenIds limited to maxSupply.\n//      */\n//     function _mint(address to, uint256 tokenId) internal override {\n//         require (tokenId < maxSupply, \"Collection: Invalid token Id\");\n//         super._mint(to, tokenId);\n//     }\n\n//     function safeTransferFromBatch(\n//         address[] memory from,\n//         address[] memory to,\n//         uint256[] memory tokenId\n//     ) public {\n//         require(from.length == tokenId.length && to.length == tokenId.length, \"Collection: you must enter same length arrays\");\n//         for(uint256 index; index < tokenId.length; index++) {\n//             safeTransferFrom(from[index], to[index], tokenId[index]);\n//         }\n//     }\n\n//     function burnBatch(uint256[] memory tokenId) public {\n//         for(uint256 index; index < tokenId.length; index++) {\n//             burn(tokenId[index]);\n//         }\n//     }\n\n//     mapping(address => uint256) userPaidValue;\n\n//     uint256 public tokenHoldersCommentFee;\n//     function setTokenHoldersCommentFee(uint256 _tokenHoldersCommentFee) public onlyOwner {\n//         tokenHoldersCommentFee = _tokenHoldersCommentFee;\n//     }\n\n//     uint256 public guestsCommentFee;\n//     function setGuestsCommentFee(uint256 _guestsCommentFee) public onlyOwner {\n//         guestsCommentFee = _guestsCommentFee;\n//     }\n\n//     uint256 public commentIndex;\n\n//     event Comment(address userAddr, uint256 holdingWeight, uint256 paidAmount, string text, uint256 typeInt, uint256 _commentIndex);\n//     /**\n//      * @notice comments as event.\n//      */\n//     function comment(string memory text, uint256 typeInt) public payable {\n//         uint256 _holdingWeight = ownerHoldingWeight(msg.sender);\n//         uint256 paidAmount = msg.value;\n//         if(_holdingWeight > 0){\n//             require(paidAmount > tokenHoldersCommentFee, \"Collection: insufficient fee for tokenHolders.\");\n//         } else {\n//             require(paidAmount > guestsCommentFee, \"Collection: insufficient fee for guest.\");\n//         }\n//         userPaidValue[msg.sender] += paidAmount;\n//         emit Comment(msg.sender, _holdingWeight, paidAmount, text, typeInt, commentIndex);\n//         commentIndex++;\n//     }\n\n//     /**\n//      * @notice Set default royalty of Collection tokens.\n//      * @notice only owner of the contract can call this function.\n//      */\n//     function setDefaultRoyalty(address royaltyReceiver, uint96 royaltyNumerator) public onlyOwner {\n//         _setDefaultRoyalty(royaltyReceiver, royaltyNumerator);\n//     }\n\n//     /**\n//      * @notice Delete default royalty of Collection tokens.\n//      * @notice only owner of the contract can call this function.\n//      */\n//     function deleteDefaultRoyalty() public onlyOwner {\n//         _deleteDefaultRoyalty();\n//     }\n\n//     /**\n//      * @notice withdraw specified amount of ETH from contract.\n//      * @notice only owner of the contract can call this funcion.\n//      */\n//     function withdraw(uint256 amount) public onlyOwner {\n//         payable(msg.sender).transfer(amount);\n//     }\n\n//     function _authorizeUpgrade(address newImplementation)\n//         internal\n//         onlyOwner\n//         override\n//     {}\n\n\n//     // weighted tokens\n\n//     mapping(uint256 => uint256) _tokenWeight;\n//     mapping(address => uint256) _ownerHoldingWeight;\n\n//     function _setTokenWeight(uint256 _weight) internal {\n//         _tokenWeight[tokenId] = _weight;\n//     }\n\n//     function tokenWeight(uint256 tokenId) public view returns(uint256) {\n//         return _tokenWeight[tokenId];\n//     }\n\n//     function ownerHoldingWeight(address _owner) public view returns(uint256) {\n//         return _ownerHoldingWeight[_owner];\n//     }\n    \n//     function _afterTokenTransfer(address from, address to, uint256 tokenId)\n//         internal\n//         override\n//     {\n//         super._afterTokenTransfer(from, to, tokenId);\n//         if(from != address(0)) {_ownerHoldingWeight[from] -= tokenWeight(tokenId);}\n//         if(to != address(0)) {_ownerHoldingWeight[to] += tokenWeight(tokenId);}\n//     }\n\n//     //voting power\n\n//     mapping(address => uint256) _lastVotingPowerRecorded;\n//     mapping(address => uint256) _lastTransferTimestamp;\n    \n//     function ownerVotingPower(address _owner) public view returns(uint256) {\n//         return _lastVotingPowerRecorded[_owner] + (block.timestamp - _lastTransferTimestamp[_owner]) / 1 days * _ownerHoldingWeight[_owner];\n//     }\n\n//     function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n//         internal\n//         override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n//     {\n//         super._beforeTokenTransfer(from, to, tokenId);\n\n//         if(from != address(0)) {\n//             _lastVotingPowerRecorded[from] = ownerVotingPower(from);\n//             _lastTransferTimestamp[from] = block.timestamp;\n//         }\n\n//         if(to != address(0)) {\n//             _lastVotingPowerRecorded[to] = ownerVotingPower(to);\n//             _lastTransferTimestamp[to] = block.timestamp;\n//         }\n\n//     }\n\n    \n//     // The following functions are overrides required by Solidity.\n\n//     function _burn(uint256 tokenId)\n//         internal\n//         override(ERC721Upgradeable, ERC721RoyaltyUpgradeable)\n//     {\n//         super._burn(tokenId);\n//     }\n\n//     function supportsInterface(bytes4 interfaceId)\n//         public\n//         view\n//         override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721RoyaltyUpgradeable)\n//         returns (bool)\n//     {\n//         return super.supportsInterface(interfaceId);\n//     }\n// }"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata",
            "storageLayout"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  },
  "output": {
    "errors": [
      {
        "component": "general",
        "errorCode": "3420",
        "formattedMessage": "Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.13;\"\n--> contracts/Collection3.sol\n\n",
        "message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.13;\"",
        "severity": "warning",
        "sourceLocation": {
          "end": -1,
          "file": "contracts/Collection3.sol",
          "start": -1
        },
        "type": "Warning"
      }
    ],
    "sources": {
      "contracts/Collection3.sol": {
        "ast": {
          "absolutePath": "contracts/Collection3.sol",
          "exportedSymbols": {},
          "id": 1,
          "license": "MIT",
          "nodeType": "SourceUnit",
          "nodes": [],
          "src": "15598:0:0"
        },
        "id": 0
      }
    }
  }
}
